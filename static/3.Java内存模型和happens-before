1.JMM:
    -线程安全一般由主内存和工作内存数据不一致导致
    -重排序导致
2.JMM结构
    -线程A -> 本地内存(包含共享变量的副本) -> 主存(包含共享变量)
    - 线程A,B之间通信 (通过共享变量来通信)
        -- a.线程A从主存中将共享变量读入到工作内存中,然后操作完写入主存
        -- b.线程B从主存中读取最新的共享变量
        -- c.脏读可以通过同步或者volatile解决
3.重排序: 为了提高性能,编译器 和 处理器通常会对指令进行重排序
    - 步骤: 源代码->编译器重排序->处理器重排序
    - 编译器重排序: 不改变单线程程序语义的情况下,可以重新安排语句的执行顺序
    - 处理器重排序: 指令集并行重排序(多条指令重叠执行),内存系统重排序(处理器使用缓存读写缓冲区,使得加载和存储操作看上去是乱序)
    - 线程安全问题解决:
        -- 编译器重排序: JMM编译器重排序规则会禁止一些特定类型的编译器重排序
        -- 处理器重排序: 编译器生成指令序列的时候会插入内存屏障
    - as-if-serial语义:不管怎么重排序,(单线程)程序的执行结果不能变.
4.happens-before规则
    - 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
    - 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
    - volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
    - 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
    - start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
    - join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
    - 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
    - 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。
5.总结
    - JMM向程序员提出happens-before规则能满足程序员需求
    - JMM对编译器和处理器的束缚尽可能少.只要不改变程序的执行结果,编译器和处理器怎么优化都可以

参考:href:https://juejin.im/post/5ae6d309518825673123fd0e
