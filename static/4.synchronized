1.synchronized
    - 方法
        -- 实例方法:锁的是实例对象
        -- 静态方法:锁的是该类的对象
    - 代码块
2.对象锁(monitor)机制
    - javap -v xxx.class可以看字节码文件
    - 锁的重入性:同一锁程中,线程不需要再获取同一把锁.synchronized拥有重入性
    - 每个对象都有一个计数器,线程获取对象锁后,计数器会+1,释放锁会-1
    - 每个对象都有自己的监视器,当对象由同步块或者同步方法调用的时候,执行方法的线程必须先获取该对象的监视器才可以进入.若没有获取监视器,则会被阻塞在同步快或者方法的入口处
3.CAS
    - cas:无锁化编程,采取一种乐观策略
    - cas操作过程:
        -- CAS(V,O,N) V代表内存中存放的实际值,O预期的值(旧值),N为更新的值
        -- 当V == O的时候,代表值没有被其他线程修改过,则V = N, 反之则不能赋值
        -- 多个线程使用CAS操作一个变量时,只有一个线程会成功更新.失败的线程会重新尝试
    - cas对比synchronized
        - syncchronized(未优化前)主要问题是多线程下会阻塞和唤醒锁带来的性能问题.是阻塞同步的
        - cas失败后会重试,而不是挂起唤醒,所以是非阻塞同步的
    - cas问题
        - ABA: A改变后又变回来了,cas检查会认为没有发生变化
            -- 解决方案: 添加版本号 1A -> 2B -> 3A
        - 自旋时间过长
        - 只能保证一个共享变量的原子操作
4.Java对象头
    - 对象的锁就是monitor标志,这个标志存放在monitor中
    - 锁状态(从低到高): 无锁,偏向锁,轻量级锁,重量级锁
    - 锁只能升级,不能降级 -> 为了提高获得锁和释放锁的效率
5.偏向锁
    - HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
6.轻量级锁

参考:href:https://juejin.im/post/5ae6dc04f265da0ba351d3ff